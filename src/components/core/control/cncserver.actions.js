/**
 * @file Abstraction for high level action rendering, management, execution.
 */
const { Raster } = require('paper');

const actions = {}; // Exposed export.

// Enumerate all valid action options.
// TODO: This likely should follow some kind of valid formating or be
// generated by child modules.
function getOptions(cncserver) {
  return () => ({
    operations: {
      fill: {
        types: {
          hatch: {
            default: true,
            settings: {},
          },
          pattern: {
            settings: {},
          },
          offset: {
            settings: {},
          },
        },
      },
      stroke: {
        types: {
          solid: {
            default: true,
          },
          dashed: {
            settings: {
              dashArray: [5, 5],
            },
          },
        },
      },
      text: {
        settings: cncserver.drawing.text.defaultSettings,
        fonts: cncserver.drawing.text.fonts,
      },
    },
    bounds: cncserver.drawing.base.defaultBoundsRaw(),
  });
}

module.exports = (cncserver) => {
  actions.projects = [];
  actions.items = [];
  actions.hashToIndex = {};

  actions.getAll = () => Object.keys(actions.hashToIndex);
  actions.getOptions = getOptions(cncserver);

  // Add a child job to a parent project.
  actions.addChild = (parent, payload) => {
    if (actions.hashToIndex[parent]) {
      // TODO: this.
    }
  };

  // Edit an item.
  // TODO: Allow this to do more.
  actions.editItem = (hash, body) => {
    const index = actions.hashToIndex[hash];

    if (body.bounds) {
      // Set bounds soft.
      actions.items[index].bounds = body.bounds;
      const item = cncserver.drawing.stage.updateItem(actions.items[index]);

      // Pull bounds directly from the item after processing.
      /* actions.items[index].bounds = {
        point: [item.bounds.point.y, item.bounds.point.x],
        size: [item.bounds.size.width, item.bounds.size.height],
      }; */
    }

    return actions.items[index];
  };

  /**
   * Normalize addItem payload between allowed types given intent. Imports
   * content to "import" layer.
   *
   * @param {string} type
   *  Type of action, project or job.
   * @param {string} operation
   *  Type of operation, trace, fill, full, or vectorize.
   * @param {string|object} body
   *  Input to be normalized, usually a string, sometimes an object.
   *
   * @return {Promise}
   *  Promise that returns on success the imported & normalized input, or error
   *  on failure.
   */
  actions.normalizeInput = (type, operation, body, color) => new Promise((success, err) => {
    const {
      drawing: {
        base: { layers },
      },
    } = cncserver;
      // Draw to empty import layer.
    layers.import.activate();
    layers.import.removeChildren();

    switch (type) {
      // If a project...
      case 'project':
        // ...for trace, fill & full, body should be Paper JSON, SVG, or file.
        if (['trace', 'fill', 'full', 'stage'].includes(operation)) {
          // Try to import as JSON directly.
          try {
            success(layers.import.importJSON(body));
          } catch (jsonError) {
            try {
              // Nope, JSON failed, try SVG (file or string content);
              success(
                layers.import.importSVG(body.trim(), {
                  expandShapes: true,
                  applyMatrix: true,
                })
              );
            } catch (svgError) {
              // Both failed!
              err(svgError);
            }
          }
        } else if (operation === 'vectorize') {
          // ...for vectorize, body must be a URL of a raster, or a file URI.
          try {
            const img = new Raster(body);
            img.onLoad = () => {
              success(img);
            };

            img.onError = (error) => {
              // TODO: This is really super unhelpful for implementors.
              err(new Error(`Problem loading image: ${error}`));
            };
          } catch (imageErr) {
            console.log('Error catch');
            // Couldn't load image.
            err(imageErr);
          }
        } else {
          err(new Error('invalid project operation'));
        }
        break;

      case 'job':
        if (['trace', 'fill', 'full', 'stage'].includes(operation)) {
          try {
            const item = cncserver.drawing.base.normalizeCompoundPath(body);
            if (operation === 'trace' && !item.strokeColor) {
              item.strokeColor = color;
            }

            if (['fill', 'full'].includes(operation) && !item.fillColor) {
              item.fillColor = color;
            }

            cncserver.drawing.base.layers.import.addChild(item);
            success(item);
          } catch (pathError) {
            // Likely couldn't parse JSON import.
            err(pathError);
          }
        } else if (operation === 'text') {
          if (typeof body === 'string') {
            success(body);
          } else {
            err(new Error('text input requires a string as the body'));
          }
        } else {
          err(new Error('invalid job operation'));
        }
        break;

      default:
        break;
    }
  });

  // Manage project or job creation into tasks & instructions.
  actions.addItem = payload => new Promise((success, err) => {
    const {
      type, operation, body, clearPreview, color = 'black',
    } = payload;

    // Clear the project preview if client requests it.
    if (type === 'project' && clearPreview) {
      cncserver.drawing.base.layers.preview.removeChildren();
      cncserver.sockets.sendPaperUpdate();
    }

    // Normalize input to match expected given type & operation.
    actions
      .normalizeInput(type, operation, body, color)
      .then((inputContent) => {
        actions
          .parseWork(payload, inputContent)
          .then((item) => {
            actions.hashToIndex[item.hash] = actions.items.length;
            actions.items.push(item);
            success(item);
          })
          .catch((error) => {
            err(error);
          });
      })
      .catch((error) => {
        err(error);
      });
  });

  // Parse an incoming payload to verify its intent.
  actions.parseWork = (payload, inputContent) => new Promise((success, err) => {
    const hash = cncserver.utils.getHash(payload);

    // Set item's name to its hash.
    inputContent.name = hash;

    const {
      type,
      parent,
      body,
      operation,
      bounds,
      settings = {},
      name,
      color = 'black',
    } = payload;

    const item = {
      hash,
      name,
      status: 'ready',
      bounds,
      operation,
      parent,
      type,
      settings,
      body,
    };

    if (type === 'job') {
      switch (operation) {
        case 'trace':
          cncserver.drawing.trace(inputContent, parent, bounds);
          success(item);
          break;

        case 'fill':
          // CLEAR the preview canvas for every job/project.
          // cncserver.drawing.base.layers.preview.removeChildren();
          cncserver.drawing.fill(inputContent, hash, null, bounds, settings);
          success(item);
          break;

        case 'text':
          settings.id = name;
          settings.color = color;
          cncserver.drawing.text.draw(
            inputContent,
            hash,
            null,
            bounds,
            settings
          );
          success(item);
          break;

        case 'stage':
          cncserver.drawing.stage.import(inputContent, hash, bounds);
          item.status = 'staged';
          success(item);
          break;

        default:
          err(new Error('invalid operation'));
          break;
      }
    } else if (type === 'project') {
      if (['trace', 'fill', 'full'].includes(operation)) {
        cncserver.drawing.project.processSVG(
          inputContent,
          parent,
          operation,
          bounds,
          settings
        );
        success(item);
      } else if (operation === 'vectorize') {
        cncserver.drawing.vectorize(inputContent, hash, bounds, settings);
        success(item);
      } else if (operation === 'stage') {
        cncserver.drawing.stage.import(inputContent, hash, bounds);
        item.status = 'staged';
        success(item);
        cncserver.sockets.sendPaperUpdate('stage');
      } else {
        err(new Error('invalid operation'));
      }
    } else {
      err(new Error('invalid action type: must be job or project'));
    }
  });

  // Get a job based on the hash.
  actions.getItem = (hash) => {
    let job = null;
    const index = actions.hashToIndex[hash];
    if (index !== undefined) {
      job = actions.items[index];
    }

    return job;
  };

  // Remove an action item based on the hash.
  actions.removeItem = (hash) => {
    let job = null;
    const index = actions.hashToIndex[hash];

    // Removing any matching items from the stage.
    if (cncserver.drawing.stage.remove(hash)) {
      cncserver.sockets.sendPaperUpdate('stage');
    }

    if (index) {
      job = actions.items[index];
      job.status = 'deleted';
    }
  };

  return actions;
};
